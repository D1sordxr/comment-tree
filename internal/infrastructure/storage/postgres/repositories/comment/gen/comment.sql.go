// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: comment.sql

package gen

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comments (
    comment_destination, parent_id, content, author
) VALUES (
    $1, $2, $3, $4
) RETURNING id, comment_destination, parent_id, author, content, created_at, updated_at
`

type CreateCommentParams struct {
	CommentDestination string         `json:"comment_destination"`
	ParentID           sql.NullInt32  `json:"parent_id"`
	Content            string         `json:"content"`
	Author             sql.NullString `json:"author"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.CommentDestination,
		arg.ParentID,
		arg.Content,
		arg.Author,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CommentDestination,
		&i.ParentID,
		&i.Author,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCommentByID = `-- name: DeleteCommentByID :exec
DELETE FROM comments
WHERE id = $1
`

func (q *Queries) DeleteCommentByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCommentByID, id)
	return err
}

const getCommentsByDestination = `-- name: GetCommentsByDestination :many
SELECT id, comment_destination, parent_id, author, content, created_at, updated_at FROM comments
WHERE comment_destination = $1
ORDER BY created_at
`

func (q *Queries) GetCommentsByDestination(ctx context.Context, commentDestination string) ([]Comment, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByDestination, commentDestination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.CommentDestination,
			&i.ParentID,
			&i.Author,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsWithChildren = `-- name: GetCommentsWithChildren :many
WITH RECURSIVE comment_tree AS (
    SELECT id, parent_id, comment_destination, author, content, created_at, updated_at
    FROM comments
    WHERE id = ANY($1::int[])

    UNION ALL

    SELECT c.id, c.parent_id, c.comment_destination, c.author, c.content, c.created_at, c.updated_at
    FROM comments c
             INNER JOIN comment_tree ct ON c.parent_id = ct.id
)
SELECT id, parent_id, comment_destination, author, content, created_at, updated_at FROM comment_tree
ORDER BY created_at ASC
`

type GetCommentsWithChildrenRow struct {
	ID                 int32          `json:"id"`
	ParentID           sql.NullInt32  `json:"parent_id"`
	CommentDestination string         `json:"comment_destination"`
	Author             sql.NullString `json:"author"`
	Content            string         `json:"content"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetCommentsWithChildren(ctx context.Context, dollar_1 []int32) ([]GetCommentsWithChildrenRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsWithChildren, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsWithChildrenRow
	for rows.Next() {
		var i GetCommentsWithChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.CommentDestination,
			&i.Author,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootCommentIDsWithPagination = `-- name: GetRootCommentIDsWithPagination :many
SELECT id FROM comments
WHERE comment_destination = $1
  AND parent_id IS NULL
  AND id > $2
ORDER BY id ASC
    LIMIT $3
`

type GetRootCommentIDsWithPaginationParams struct {
	CommentDestination string `json:"comment_destination"`
	ID                 int32  `json:"id"`
	Limit              int32  `json:"limit"`
}

func (q *Queries) GetRootCommentIDsWithPagination(ctx context.Context, arg GetRootCommentIDsWithPaginationParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getRootCommentIDsWithPagination, arg.CommentDestination, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
